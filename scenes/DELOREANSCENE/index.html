<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DeLorean R0_MA Scene</title>

    <style>
        body { margin: 0; overflow: hidden; background: black; }
        #loadingScreen {
            position: fixed; inset: 0;
            background: black; color: white;
            display: flex; justify-content: center; align-items: center;
            font-size: 22px; z-index: 1000;
        }
        #startBtn {
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            background: #00aaff;
            color: white; border: none; border-radius: 8px;
            font-size: 18px; cursor: pointer;
            z-index: 2000;
            display: none;
        }
        canvas { display: block; }
    </style>
</head>
<body>

<div id="loadingScreen">Cargando...scene by VICTOR ALBARO</div>
<button id="startBtn">INICIAR ENERGÍA</button>
<canvas id="webgl"></canvas>

<!-- Three.js + GLTFLoader + OrbitControls -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
let scene, camera, renderer;
let delorean, ciudad;
let pivot;
let controls;
let listener, music;

// Efectos
let energyParticles, energyMaterial;
let rearOrbs = [];

// Estados
let introOrbit = true;
let energyActivating = false;
let energyActive = false;
let finalOrbit = false;
let energyTime = 0;
let orbsFadingOut = false;


// Duración de activación
const ACTIVATION_DURATION = 20;

// Posición base del DeLorean (centrado)
const DELOREAN_BASE_POS = new THREE.Vector3(0, 3, 0);

// Posición final de cámara antes de liberar controles
const FINAL_CAMERA_POS = new THREE.Vector3(0, 4, 10);

// ===============================
// INIT
// ===============================
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x080008);

    // Cámara
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.set(0, 1.8, 4.5);

    // Pivot
    pivot = new THREE.Object3D();
    scene.add(pivot);
    pivot.add(camera);

    // Renderer
    const canvas = document.getElementById("webgl");
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    // OrbitControls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enabled = false;
    controls.minDistance = 3;
    controls.maxDistance = 40;
    controls.maxPolarAngle = Math.PI / 1.1; //2.2

    // Luces
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));

    const dir = new THREE.DirectionalLight(0xff00ff, 0.6);
    dir.position.set(0, 5, 10); //10,20,30
    scene.add(dir);

    const point1 = new THREE.PointLight(0xffffff, 1, 200);
    point1.position.set(5, 10, 5);
    scene.add(point1);

    const rim = new THREE.DirectionalLight(0x0088ff, 0.4);
    rim.position.set(0, 5, -10); // detrás del coche
    scene.add(rim);

    const warmBounce = new THREE.PointLight(0xff6600, 0.2, 20);
    warmBounce.position.set(0, 1, 0); // justo debajo del coche
    scene.add(warmBounce);

    // Carretera
    /*const road = new THREE.Mesh(
        new THREE.PlaneGeometry(500, 5000),
        new THREE.MeshStandardMaterial({ color: 0x0A0A0A })
    );
    road.rotation.x = -Math.PI / 2;
    scene.add(road);*/

    // Estrellas
    crearEstrellas();

    // Audio
    setupAudio();

    // Modelos
    loadModels();

    window.addEventListener("resize", onResize);
    animate();
}

// ===============================
// ESTRELLAS
// ===============================
function crearEstrellas() {
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 500;
    const positions = [];

    for (let i = 0; i < starCount; i++) {
        positions.push(
            (Math.random() - 0.5) * 2000,
            (Math.random() - 0.5) * 2000,
            (Math.random() - 0.5) * 2000
        );
    }

    starGeometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));

    const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.7
    });

    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);
}

// ===============================
// AUDIO
// ===============================
function setupAudio() {
    listener = new THREE.AudioListener();
    camera.add(listener);

    music = new THREE.Audio(listener);

    const audioLoader = new THREE.AudioLoader();
    audioLoader.load("assets/musica.mp3", function(buffer) {
        music.setBuffer(buffer);
        music.setLoop(true);
        music.setVolume(0.4);
        music.play();
    });
}

// ===============================
// LOAD MODELS
// ===============================
function loadModels() {
    const loader = new THREE.GLTFLoader();

    loader.load("assets/ciudad.glb/cityregresoFuturo.glb", function(gltf) {
        ciudad = gltf.scene;
        scene.add(ciudad);
    });

    loader.load("assets/delorean10.glb/delorean.glb", function(gltf) {
        delorean = gltf.scene;
        delorean.position.copy(DELOREAN_BASE_POS);
        delorean.rotation.y = Math.PI;
        scene.add(delorean);

        crearEnergyParticles();
        crearRearOrbs();

        document.getElementById("loadingScreen").style.display = "none";
        document.getElementById("startBtn").style.display = "block";
    });
}

// ===============================
// PARTÍCULAS DE ENERGÍA
// ===============================
function crearEnergyParticles() {
    const particleGeometry = new THREE.BufferGeometry();
    const count = 1000;
    const positions = [];
    const radius = 4.3;

    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const y = (Math.random() - 0.5) * 1.2;
        const r = radius * (0.5 + Math.random() * 0.5); 

        positions.push(
            Math.cos(angle) * r,
            y,
            Math.sin(angle) * r
        );
    }

    particleGeometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));

    energyMaterial = new THREE.PointsMaterial({
        color: 0x66ccff,
        size: 0.03,
        transparent: true,
        opacity: 0.0
    });

    energyParticles = new THREE.Points(particleGeometry, energyMaterial);
    delorean.add(energyParticles);
}

// ===============================
// BOLAS AZULES TRASERAS
// ===============================
function crearRearOrbs() {
    const orbGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    const orbMaterial = new THREE.MeshStandardMaterial({
    color: 0x00aaff,
    emissive: 0x0088ff,
    emissiveIntensity: 1.5,
    transparent: true,
    opacity: 0.9
});


    const offsets = [
        new THREE.Vector3(-0.55, 1.2, -3.3),
        new THREE.Vector3( 0.55, 1.2, -3.3),
    ];

    offsets.forEach(offset => {
        const orb = new THREE.Mesh(orbGeometry, orbMaterial.clone());
        orb.position.copy(offset);
        orb.scale.set(0.1, 0.1, 0.1);
        delorean.add(orb);
        rearOrbs.push({ mesh: orb, baseOffset: offset.clone() });
    });
}

// ===============================
// INICIAR ENERGÍA
// ===============================
function iniciarEnergia() {
    if (!delorean || energyActivating || energyActive) return;

    document.getElementById("startBtn").style.display = "none";

    energyActivating = true;
    energyTime = 0;

    if (music && music.isPlaying) {
        music.setVolume(0.6);
    }
}

document.getElementById("startBtn").onclick = iniciarEnergia;

// ===============================
// ANIMATE
// ===============================
function animate() {
    requestAnimationFrame(animate);

    const delta = 0.016;

    if (delorean) {
        pivot.position.copy(delorean.position);

        if (introOrbit) {
            pivot.rotation.y += 0.0015;
        }

        if (energyActivating) {
            energyTime += delta;

            const vib = 0.05 + Math.min(energyTime * 0.03, 0.15);
            delorean.position.x = DELOREAN_BASE_POS.x + Math.sin(energyTime * 20) * vib;
            delorean.position.z = DELOREAN_BASE_POS.z + Math.cos(energyTime * 20) * vib;

            if (energyMaterial) {
                energyMaterial.opacity = Math.min(1.0, energyTime * 0.05);
            }

            rearOrbs.forEach((o, i) => {
                const baseScale = 0.1 + Math.min(energyTime * 0.1, 1.0);
                const pulse = 1.0 + Math.sin(energyTime * 10 + i) * 0.2;
                const s = baseScale * pulse;
                o.mesh.scale.set(s, s, s);
            });

            pivot.rotation.y += 0.003;

            if (energyTime > ACTIVATION_DURATION) {
                energyActivating = false;
                finalOrbit = true;
                introOrbit = false;
                orbsFadingOut = true;

                delorean.position.copy(DELOREAN_BASE_POS);

                if (energyMaterial) {
                    energyMaterial.opacity = 0.8;
                }

                if (music && music.isPlaying) {
                    music.setVolume(0.45);
                }
            }
        }

        if (finalOrbit) {
            pivot.rotation.y += 0.0015;

            camera.position.lerp(FINAL_CAMERA_POS, 0.01);

            if (camera.position.distanceTo(FINAL_CAMERA_POS) < 0.2) {
                finalOrbit = false;
                energyActive = true;

                controls.enabled = true;
                controls.target.copy(delorean.position);
                controls.update();
            }
        }

        if (energyActive) {
            const t = performance.now() * 0.001;
            const vib = 0.03;
            delorean.position.x = DELOREAN_BASE_POS.x + Math.sin(t * 15) * vib;
            delorean.position.z = DELOREAN_BASE_POS.z + Math.cos(t * 15) * vib;

            if (energyParticles) {
                energyParticles.rotation.y += 0.004;
            }
            if (orbsFadingOut) {
                rearOrbs.forEach((o) => {
                    // Reducir opacidad
                    o.mesh.material.opacity -= 0.01;

                    // Reducir tamaño
                    o.mesh.scale.multiplyScalar(0.97);

                    // Cuando desaparezcan, eliminarlos
                    if (o.mesh.material.opacity <= 0) {
                        delorean.remove(o.mesh);
        }
    });

    // Cuando todos hayan desaparecido, desactivar fade-out
    if (rearOrbs.every(o => o.mesh.material.opacity <= 0)) {
        orbsFadingOut = false;
    }
}


            rearOrbs.forEach((o, i) => {
                const pulse = 0.9 + Math.sin(t * 4 + i) * 0.2;
                o.mesh.scale.set(pulse, pulse, pulse);
            });
        }
    }

    renderer.render(scene, camera);
}

// ===============================
// RESIZE
// ===============================
function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

window.addEventListener("DOMContentLoaded", init);
</script>

</body>
</html>
